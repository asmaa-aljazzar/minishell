/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   allocate_argv.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/24 18:23:56 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 19:39:29 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Allocate argv for current cmd (+1 for NULL)
#include "minishell.h"

void allocate_argv(t_minishell *minishell, int *argc, t_command **cmd, int *i)
{
	t_token *token = minishell->tok[*i];

	if (token->type == INPUT_PIPE || token->type == OUTPUT_PIPE)
	{
		(*cmd)->argv = malloc(sizeof(char *) * (*argc + 1));
		if (!(*cmd)->argv)
			ft_exit(minishell, "malloc failed", EXIT_FAILURE);
		*argc = 0;
		*cmd = (*cmd)->next;
	}
	else if (token->type != INPUT_FILE && token->type != INPUT_HEREDOC
		&& token->type != OUTPUT_FILE && token->type != OUTPUT_APPEND)
	{
		(*argc)++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   argv_for_commands.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/24 18:20:45 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 19:38:20 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Last if is for last command
void argv_for_commands(t_minishell *minishell)
{
	t_command *cmd = minishell->cmd;
	int i = 0;
	int argc = 0;

	while (minishell->tok[i])
	{
		allocate_argv(minishell, &argc, &cmd, &i);
		i++;
	}
	if (cmd) // for the final command after last pipe
	{
		cmd->argv = malloc(sizeof(char *) * (argc + 1));
		if (!cmd->argv)
			ft_exit(minishell, "malloc failed", EXIT_FAILURE);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/02 22:14:22 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 18:30:26 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

//? Steps:
//* 1. Initialize some of elements in the structure.
//* 2. Enter an infinite loop to display prompts.
//* 3. Clear the history if the loop has been broken.
int main(int ac, char **av, char **environ)
{
	(void)ac;
	(void)av;
	t_minishell minishell;

	init(&minishell);
	minishell.env = init_env(&minishell, environ);
	main_loop(&minishell);
	rl_clear_history();
	return (0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_fork.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/02 22:14:18 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/11 21:34:57 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Fork a child process in the main.
// Redirection in child.
// Compare the command in commands array to execute them
// Redirection in child.

void main_fork(t_minishell *minishell)
{
    (void)minishell;
    int pid;
    pid = fork ();
    if (pid == 0)
    {
        // child_re(minishell);
        // compare_commands (minishell);
    }
    else
    {
        // parent_re(minishell);
        int status;
        waitpid(pid, &status, 0);
    }
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_loop.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/24 15:32:00 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 19:32:10 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Initialize the shell & tokenize the input.
// Run exit command if found.
// Initialize commands pipeline.
// Expand env variables.
// Merge words that not separated by spaces.
// Set argv array for commands nodes.
// Complete convert tokens array into commands linkedlist

void main_loop(t_minishell *minishell)
{
	while (1)
	{
		init_shell(minishell);
		if (!minishell->input || !minishell->tok)
			continue;
		exit_command(minishell);
		init_commands(minishell);
		expand_tokens(minishell);
		merge_words(minishell);
		argv_for_commands(minishell);
		tokens_to_commands(minishell);
		debug_Display_t_command(minishell);
		check_to_free(minishell);
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   count_pipe.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/11 20:46:27 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/11 21:52:42 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
void count_pipe(t_minishell *minishell)
{
    int i = 0;
    int pipes = 0;
    char *input = minishell->input;
    while (input[i])
    {
        if (input[i] == '|')
            pipes += 1;
        i++;
    }
    minishell->pipe_count = pipes;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_tokens.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/03 00:52:12 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 14:00:45 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void get_tokens(t_minishell *ms)
{
    size_t len = ft_strlen(ms->input);
    int i = 0;
    int k = 0;

    ms->tok = ft_calloc(len + 1, sizeof(t_token *));
    if (!ms->tok)
        ft_exit(ms, "malloc failed", 1);

    while (ms->input[i])
    {
        int glued = 1;  // Default to glued

        /* Skip leading blanks */
        if (ms->input[i] == ' ')
        {
            glued = 0;  // Next token is NOT glued
            while (ms->input[i] == ' ')
                i++;
        }
        
        if (!ms->input[i])
            break;

        // First token is never glued
        if (k == 0)
            glued = 0;

        if (ms->input[i] == '|')
            tokenize_pipe_op(ms, &k, &i);
        else if (ms->input[i] == '<' || ms->input[i] == '>')
            tokenize_redir_op1(ms, &k, &i);
        else
            tokenize_quoted(ms, &k, &i, glued);
    }
    ms->tok[k] = NULL;
    ms->tokens_count = k;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   merge_words.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 15:34:15 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/23 17:56:23 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
/*
** This function merges consecutive WORD tokens that should be "glued" together
** because they appeared in the input string with no spaces between them.
** For example: "HELLO"'$USER' becomes one token "HELLOasmaa".
**
** It works by using two pointers:
** - 'i' is the "read" pointer, which iterates through the original token array.
** - 'k' is the "write" pointer, which points to the position in the new,
**   condensed token array.
*/
void merge_words(t_minishell *ms)
{
    t_token **orig;
    int       i;
    int       k;

    if (!ms || !ms->tok)
        return;

    orig = ms->tok;
    i = 0; // read index
    k = 0; // write index

    while (orig[i])
    {
        // Always copy the current token to the write position.
        // If they are the same token (i == k), this does nothing.
        // If tokens have been merged, this moves a later token to an earlier slot.
        ms->tok[k] = orig[i];

        // Check if the NEXT token can be merged into the CURRENT one.
        while (orig[i + 1]
               && ms->tok[k]->type == INUPT_WORD
               && orig[i + 1]->type == INUPT_WORD
               && orig[i + 1]->glued == 1)
        {
            char *joined_word;

            // Merge the two words together.
            joined_word = ft_strjoin(ms->tok[k]->word, orig[i + 1]->word);
            if (!joined_word)
                ft_exit(ms, "malloc failed", 1);

            // Free the old word in our destination token.
            free(ms->tok[k]->word);
            // Assign the new, joined word.
            ms->tok[k]->word = joined_word;

            // *** THE MAIN FIX IS HERE ***
            // We MUST free the token that we just absorbed, otherwise it is a memory leak.
            free(orig[i + 1]->word);
            free(orig[i + 1]);

            // Advance the read pointer ('i') to skip over the token we just merged.
            i++;
        }
        // Advance both pointers to move to the next position.
        k++;
        i++;
    }

    // Null-terminate the new, shorter token array.
    ms->tok[k] = NULL;
    // Update the total token count.
    ms->tokens_count = k;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_normal_string.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 07:14:49 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 14:01:03 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
void tokenize_normal_string(t_minishell *minishell, int *k, int *i, int glued)
{
    char *word;
    int size;
    int start = *i;
    
    // Move glued assignment AFTER token allocation
    
    while (minishell->input[*i] && minishell->input[*i] != ' ' 
        && minishell->input[*i] != '\'' && minishell->input[*i] != '"' 
        && minishell->input[*i] != '>' && minishell->input[*i] != '<' 
        && minishell->input[*i] != '|')
        (*i)++;

    size = *i - start;
    
    // Skip empty tokens
    if (size == 0)
        return;
        
    // Allocate memory for the word
    word = calloc(1, size + 1);
    if (!word)
        ft_exit(minishell, "Memory allocation failed", 1);
        
    ft_strlcpy(word, &minishell->input[start], size + 1);
    
    // Allocate and initialize the token structure FIRST
    minishell->tok[*k] = calloc(1, sizeof(t_token));
    if (!minishell->tok[*k])
    {
        free(word);  // Don't forget to free word on failure
        ft_exit(minishell, "Memory allocation failed", 1);
    }
        
    // NOW set all token fields (including glued)
    minishell->tok[*k]->word = word;
    minishell->tok[*k]->type = INUPT_WORD;
    minishell->tok[*k]->qtype = QUOTE_NONE;
    minishell->tok[*k]->glued = glued;  // Moved here
    
    (*k)++;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_op.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/14 05:24:07 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 13:57:52 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void tokenize_pipe_op(t_minishell *minishell, int *k, int *i)
{
    minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
    if (!minishell->tok[*k])
        ft_exit(minishell, "Memory allocation failed", 1);
    minishell->tok[*k]->word = ft_strdup("|");
    minishell->tok[*k]->type = OUTPUT_PIPE;
    minishell->tok[*k]->qtype = QUOTE_NONE;
    (*k)++;
    (*i)++;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_quoted.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 07:15:41 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 19:44:59 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
void tokenize_quoted(t_minishell *minishell, int *k, int *i, int glued)
{
    int size;
    int start;
    char *word;
    char quote;

    if (minishell->input[*i] == '\'' || minishell->input[*i] == '"')
    {
        quote = minishell->input[(*i)++];
        start = *i;
        while (minishell->input[*i] && minishell->input[*i] != quote)
            (*i)++;
        if (minishell->input[*i] != quote)
        {
            ft_putendl_fd("Syntax error: unmatched quote", STDERR_FILENO);
            return ;
        }
        size = *i - start;
        word = malloc(size + 1);
        if (!word)
            ft_exit(minishell, "Memory allocation failed", 1);

        ft_strlcpy(word, &minishell->input[start], size + 1);

        // Allocate the token structure
        minishell->tok[*k] = calloc(1, sizeof(t_token));
        if (!minishell->tok[*k])
        {
            free(word);
            ft_exit(minishell, "Memory allocation failed", 1);
        }

        minishell->tok[*k]->word = word;
        minishell->tok[*k]->type = INUPT_WORD;
        minishell->tok[*k]->glued = glued;  // Use the passed glued value
        if (quote == '"')
            minishell->tok[*k]->qtype = QUOTE_DOUBLE;
        else
            minishell->tok[*k]->qtype = QUOTE_SINGLE;
        (*k)++;
        (*i)++;
    }
    else
    {
        tokenize_normal_string(minishell, k, i, glued);
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_redir_op1.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 07:17:12 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 14:00:28 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void tokenize_redir_op1(t_minishell *minishell, int *k, int *i)
{
    if (minishell->input[*i] == '<')
    {
        if (minishell->input[*i + 1] == '<')
        {
            minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
            if (!minishell->tok[*k])
                ft_exit(minishell, "Memory allocation failed", 1);
            minishell->tok[*k]->word = ft_strdup("<<");
            minishell->tok[*k]->type = INPUT_HEREDOC;
            minishell->tok[*k]->qtype = QUOTE_NONE;
            (*k)++;
            (*i) += 2;
        }
        else
        {
            minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
            if (!minishell->tok[*k])
                ft_exit(minishell, "Memory allocation failed", 1);
            minishell->tok[*k]->word = ft_strdup("<");
            minishell->tok[*k]->type = INPUT_FILE;
            minishell->tok[*k]->qtype = QUOTE_NONE;
            (*k)++;
            (*i)++;
        }
    }
    else if (minishell->input[*i] == '>')
        tokenize_redir_op2(minishell, k, i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_redir_op2.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 07:17:47 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 14:00:33 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void tokenize_redir_op2(t_minishell *minishell, int *k, int *i)
{
    if (minishell->input[*i + 1] == '>')
    {
        minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
        if (!minishell->tok[*k])
            ft_exit(minishell, "Memory allocation failed", 1);
        minishell->tok[*k]->word = ft_strdup(">>");
        minishell->tok[*k]->type = OUTPUT_APPEND;
        minishell->tok[*k]->qtype = QUOTE_NONE;
        (*k)++;
        (*i) += 2;
    }
    else
    {
        minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
        if (!minishell->tok[*k])
            ft_exit(minishell, "Memory allocation failed", 1);
        minishell->tok[*k]->word = ft_strdup(">");
        minishell->tok[*k]->type = OUTPUT_FILE;
        minishell->tok[*k]->qtype = QUOTE_NONE;
        (*k)++;
        (*i)++;
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/02 22:14:38 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 18:34:30 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void init(t_minishell *minishell)
{
    minishell->tok = NULL;
    minishell->input = NULL;
    minishell->cmd = NULL;
    minishell->tokens_count = 0;
    minishell->pipe_count = 0;
    ft_memset(minishell->buff, 0, sizeof(minishell->buff));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_commands.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/11 20:22:25 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/23 14:00:56 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void init_commands(t_minishell *minishell)
{
    t_command *head = NULL;
    t_command *curr = NULL;
    int count = minishell->pipe_count;
    int i = 0;

    while (i <= count)
    {
        t_command *new = malloc(sizeof(t_command));
        if (!new)
            ft_exit(minishell, "malloc failed", EXIT_FAILURE);

        new->argv = NULL;
        new->input_type = INPUT_NONE;
        new->output_type = OUTPUT_NONE;
        new->input_file = NULL;
        new->output_file = NULL;
        new->next = NULL;

        if (!head)
        {
            head = new;
            curr = new;
        }
        else
        {
            curr->next = new;
            curr = new;
        }
        i++;
    }
    minishell->cmd = head;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/16 14:48:52 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 19:18:08 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_env *create_env_node(t_minishell *minishell, char *env_string);

// Loop over environ arrtibute.
// make head is new node if no nodes yet.
// other wise the tail->next will be the new node.

t_env *init_env(t_minishell *minishell, char **environ)
{
    t_env *head = NULL;
    t_env *tail = NULL;
    t_env *new_node;
    int i = 0;

    while (environ[i])
    {
        new_node = create_env_node(minishell, environ[i]);
        if (new_node)
        {
            if (!head)
                head = new_node;
            else
                tail->next = new_node;
            tail = new_node;
        }
        i++;
    }
    return head;
}

//#### A helper function for init_env function
//- Determine the position of [ = ].
//- Allocate memory for each env node.
//- Extract name and value use (substr, strdup).
static t_env *create_env_node(t_minishell *minishell, char *env_string)
{
    char *equal = ft_strchr(env_string, '=');
    t_env *node;

    if (!equal)
        return NULL;
    node = malloc(sizeof(t_env));
    if (!node)
        ft_exit(minishell, "Memory allocation failed", 1);
    node->name = ft_substr(env_string, 0, equal - env_string);
    node->value = ft_strdup(equal + 1);
    node->next = NULL;
    return node;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_shell.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aaljazza <aaljazza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/02 22:14:35 by aaljazza          #+#    #+#             */
/*   Updated: 2025/07/24 20:18:06 by aaljazza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"


int validate_syntax(t_minishell *ms)
{
    int i;

    i= 0;
    while (ms->tok[i])
    {
        // Check for empty pipe
        if (ms->tok[i]->type == OUTPUT_PIPE)
        {
            if (i == 0 || !ms->tok[i + 1] || ms->tok[i + 1]->type == OUTPUT_PIPE)
            {
                ft_putendl_fd("syntax error near unexpected token `|'", 2);
                return 0;
            }
        }
        // Check for redirections
        else if (ms->tok[i]->type == INPUT_FILE || 
                 ms->tok[i]->type == INPUT_HEREDOC || 
                 ms->tok[i]->type == OUTPUT_FILE || 
                 ms->tok[i]->type == OUTPUT_APPEND)
        {
            // Must have a word token after redirection
            if (!ms->tok[i + 1] || ms->tok[i + 1]->type != INUPT_WORD)  // Note: Fix the typo INUPT_WORD to INPUT_WORD in your enum
            {
                ft_putendl_fd("syntax error near unexpected token `newline'", 2);
                return 0;
            }
            i++; // Skip the filename token we just validated
        }
        i++;
    }
    return 1;
}

// 1. Display the prompt.
// 2. Read the input line into a buffer.
// 3. Add this line to the history.
// 4. Parsing the input.
// 5. Split it into tokens.
//? 6. Move it into cmd array.
// 7. After Each initialize check for Null.
// 8. exit if error occured
void init_shell(t_minishell *minishell)
{
    // Reset tokens from previous iteration
    minishell->tok = NULL;
    minishell->tokens_count = 0;
    minishell->pipe_count = 0;
    
    // Get user input with readline
    minishell->input = readline(PROMPT);
    
    // Handle EOF (Ctrl+D)
    if (!minishell->input)
    {
        printf("exit\n");
        free_env(minishell->env);
        rl_clear_history();
        exit(0);
    }

    // Add non-empty commands to history
    if (*minishell->input)
        add_history(minishell->input);

    // Skip processing for empty commands
    if (!*minishell->input)
    {
        free(minishell->input);
        minishell->input = NULL;
        return;
    }

    // Tokenize the input
    get_tokens(minishell);
    if (!minishell->tok)
    {
        ft_putendl_fd("Error: Failed to tokenize input", STDERR_FILENO);
        free(minishell->input);
        minishell->input = NULL;
        return;
    }
    if (!validate_syntax(minishell))
    {
        check_to_free(minishell);
        return;
    }

    // Handle single built-in commands (no pipes)
    if (minishell->tok[0] && minishell->tok[1] == NULL)
    {
        // env command
        if (ft_strncmp(minishell->tok[0]->word, "env", ft_strlen("env") + 1) == 0)
        {
            env_builtin(minishell);
            check_to_free(minishell);
            return;
        }
    }
    
    // Handle built-ins that can have arguments
    if (minishell->tok[0])
    {
        // export
        if (ft_strncmp(minishell->tok[0]->word, "export", ft_strlen("export") + 1) == 0)
        {
            export_builtin(minishell);
            check_to_free(minishell);
            return;
        }
        // unset
        else if (ft_strncmp(minishell->tok[0]->word, "unset", ft_strlen("unset") + 1) == 0)
        {
            unset_builtin(minishell);
            check_to_free(minishell);
            return;
        }
    }

    // Count pipes to determine number of commands
    count_pipe(minishell);
    
    // Set default exit code for this command
    minishell->exit_code = 0;
}
