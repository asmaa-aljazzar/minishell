
#include "minishell.h"

void advance_and_merge(t_minishell *minishell, t_token **orig, int *i, int k)
{
	while (orig[*i + 1]
		&& minishell->tok[k]->type == INUPT_WORD
		&& orig[*i + 1]->type == INUPT_WORD
		&& orig[*i + 1]->glued == 1)
	{
		merge_two_tokens(minishell, minishell->tok[k], orig[*i + 1]);
		(*i)++;
	}
}
#include "minishell.h"

char *allocate_normal_word(t_minishell *ms, int start, int len)
{
	char *word = calloc(1, len + 1);
	if (!word)
		ft_exit(ms, "Memory allocation failed", 1);

	ft_strlcpy(word, &ms->input[start], len + 1);
	return word;
}
#include "minishell.h"

void count_pipe(t_minishell *minishell)
{
    int i = 0;
    int pipes = 0;
    char *input = minishell->input;
    while (input[i])
    {
        if (input[i] == '|')
            pipes += 1;
        i++;
    }
    minishell->pipe_count = pipes;
}
#include "minishell.h"

void merge_two_tokens(t_minishell *minishell, t_token *dst, t_token *src)
{
	char *joined_word = ft_strjoin(dst->word, src->word);
	if (!joined_word)
		ft_exit(minishell, "malloc failed", 1);
	free(dst->word);
	dst->word = joined_word;
	free_token(src);
}
#include "minishell.h"

void merge_words(t_minishell *minishell)
{
	t_token **orig;
	int i;
	int k;
    
    i = 0;
    k = 0;
	if (!minishell || !minishell->tok)
		return;
	orig = minishell->tok;
	while (orig[i])
	{
		minishell->tok[k] = orig[i];
		advance_and_merge(minishell, orig, &i, k);
		k++;
		i++;
	}
	minishell->tok[k] = NULL;
	minishell->tokens_count = k;
}

#include "minishell.h"

char *read_quoted_content(t_minishell *ms, int *i, char quote)
{
	int start = ++(*i);
	while (ms->input[*i] && ms->input[*i] != quote)
		(*i)++;

	if (ms->input[*i] != quote)
	{
		ft_putstr_fd("Syntax error: unmatched quote", STDERR_FILENO);
		return NULL;
	}
	int size = *i - start;
	char *word = malloc(size + 1);
	if (!word)
		ft_exit(ms, "Memory allocation failed", 1);
	ft_strlcpy(word, &ms->input[start], size + 1);
	return word;
}
#include "minishell.h"

// [ free(old_list) ] Only pointer, not the strings inside

char **add_to_list(char **old_list, char *value)
{
	int len;
	len = 0;
	while (old_list && old_list[len])
		len++;
	char **new_list = malloc(sizeof(char *) * (len + 2));
	if (!new_list)
		return NULL;
	int i;
	i = 0;
	while (i < len)
	{
		new_list[i] = old_list[i];
		i++;
	}
	new_list[len] = ft_strdup(value);
	new_list[len + 1] = NULL;
	free(old_list); 
	return new_list;
}

#include "minishell.h"


t_command *create_command(t_minishell *minishell)
{
	t_command *new = malloc(sizeof(t_command));
	if (!new)
		ft_exit(minishell, "malloc failed", EXIT_FAILURE);

	new->argv = NULL;
	new->input_type = INPUT_NONE;
	new->output_type = OUTPUT_NONE;
	new->input_file = NULL;
	new->input_files = NULL;
	new->output_file = NULL;
	new->output_files = NULL;
	new->next = NULL;

	return new;
}

#include "minishell.h"

int has_more_redirections(t_token **tokens, int start_index, t_type t1, t_type t2)
{
	int i = start_index;
	while (tokens[i])
	{
		if (tokens[i]->type == t1 || tokens[i]->type == t2)
			return 1;
		i++;
	}
	return 0;
}
#include "minishell.h"

void if_input_filesHeredoc(t_minishell *minishell, t_token *token, t_command **cmd, int *i)
{
    if (token->type == INPUT_FILE || token->type == INPUT_HEREDOC)
    {
        if (minishell->tok[(*i) + 1])
        {
            char *file = minishell->tok[++(*i)]->word;
            if (has_more_redirections(minishell->tok, *i + 1, INPUT_FILE, INPUT_HEREDOC))
                (*cmd)->input_files = add_to_list((*cmd)->input_files, file);
            else
            {
                (*cmd)->input_type = token->type;
                (*cmd)->input_file = ft_strdup(file);
            }
        }
    }
}
#include "minishell.h"

void if_output_filesAppend(t_minishell *minishell, t_token *token, t_command **cmd, int *i)
{
    if (token->type == OUTPUT_FILE || token->type == OUTPUT_APPEND)
    {
        if (minishell->tok[(*i) + 1])
        {
            char *file = minishell->tok[++(*i)]->word;
            if (has_more_redirections(minishell->tok, *i + 1, OUTPUT_FILE, OUTPUT_APPEND))
                (*cmd)->output_files = add_to_list((*cmd)->output_files, file);
            else
            {
                (*cmd)->output_type = token->type;
                (*cmd)->output_file = ft_strdup(file); // FIX: Duplicate this too
            }
        }
    }
}
#include "minishell.h"

void if_outputPipe(t_token *token, t_command **cmd, int *argc)
{

	if (token->type == OUTPUT_PIPE)
	{
		if (*cmd && (*cmd)->argv)
			(*cmd)->argv[*argc] = NULL;

	
		if (*cmd)
			*cmd = (*cmd)->next;
		*argc = 0;
	}
}
#include "minishell.h"

void tokens_to_commands(t_minishell *minishell)
{
	t_command *cmd;
	t_token *token;

	cmd = minishell->cmd;
	int i = 0;
	int argc = 0;
	while (minishell->tok[i])
	{
		token = minishell->tok[i];
		if_outputPipe(token, &cmd, &argc);
		if_input_filesHeredoc(minishell, token, &cmd, &i);
		if_output_filesAppend(minishell, token, &cmd, &i);
		if (token->type == INUPT_WORD)
			cmd->argv[argc++] = token->word;
		i++;
	}
	if (cmd && cmd->argv)
		cmd->argv[argc] = NULL;
}

#include "minishell.h"

void create_quoted_token(t_minishell *ms, int *k, char *word, char quote, int glued)
{
	ms->tok[*k] = ft_calloc(1, sizeof(t_token));
	if (!ms->tok[*k])
	{
		free(word);
		ft_exit(ms, "Memory allocation failed", 1);
	}
	ms->tok[*k]->word = word;
	ms->tok[*k]->type = INUPT_WORD;
	ms->tok[*k]->qtype = (quote == '"') ? QUOTE_DOUBLE : QUOTE_SINGLE;
	ms->tok[*k]->glued = glued;
	(*k)++;
}
#include "minishell.h"

void get_tokens(t_minishell *minishell)
{
	size_t len = ft_strlen(minishell->input);
	int i = 0;
	int k = 0;

	minishell->tok = ft_calloc(len + 1, sizeof(t_token *));
	if (!minishell->tok)
		ft_exit(minishell, "malloc failed", 1);

	while (minishell->input[i])
		process_token(minishell, &k, &i);

	minishell->tok[k] = NULL;
	minishell->tokens_count = k;
}



#include "minishell.h"

void process_token(t_minishell *minishell, int *k, int *i)
{
	int glued;
	
	glued = 1;
	if (minishell->input[*i] == ' ')
	{
		glued = 0;
		while (minishell->input[*i] == ' ')
			(*i)++;
	}
	if (!minishell->input[*i])
		return;
	if (*k == 0)
		glued = 0;
	if (minishell->input[*i] == '|')
		tokenize_pipe_op(minishell, k, i);
	else if (minishell->input[*i] == '<' || minishell->input[*i] == '>')
		tokenize_input_redir(minishell, k, i);
	else
		tokenize_quoted(minishell, k, i, glued);
}

#include "minishell.h"

void tokenize_input_redir(t_minishell *minishell, int *k, int *i)
{
	if (minishell->input[*i] == '<')
	{
		if (minishell->input[*i + 1] == '<')
			handle_heredoc_redir(minishell, k, i);
		else
			handle_input_file_redir(minishell, k, i);
	}
	else if (minishell->input[*i] == '>')
		tokenize_output_redir(minishell, k, i);
}

#include "minishell.h"

void tokenize_normal_string(t_minishell *minishell, int *k, int *i, int glued)
{
	int start = *i;
	char *word;

	while (minishell->input[*i] && minishell->input[*i] != ' ' 
		&& minishell->input[*i] != '\'' && minishell->input[*i] != '"' 
		&& minishell->input[*i] != '>' && minishell->input[*i] != '<' 
		&& minishell->input[*i] != '|')
		(*i)++;

	if (*i - start == 0)
		return;

	word = allocate_normal_word(minishell, start, *i - start);
	init_normal_token(minishell, word, glued, k);
}


#include "minishell.h"

void tokenize_output_redir(t_minishell *minishell, int *k, int *i)
{
	if (minishell->input[*i + 1] == '>')
		handle_output_append_redir(minishell, k, i);
	else
		handle_output_file_redir(minishell, k, i);
}

#include "minishell.h"

void tokenize_pipe_op(t_minishell *minishell, int *k, int *i)
{
    minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
    if (!minishell->tok[*k])
        ft_exit(minishell, "Memory allocation failed", 1);
    minishell->tok[*k]->word = ft_strdup("|");
    minishell->tok[*k]->type = OUTPUT_PIPE;
    minishell->tok[*k]->qtype = QUOTE_NONE;
    (*k)++;
    (*i)++;
}
#include "minishell.h"

void tokenize_quoted(t_minishell *ms, int *k, int *i, int glued)
{
	if (ms->input[*i] == '\'' || ms->input[*i] == '"')
	{
		char quote = ms->input[*i];
		char *word = read_quoted_content(ms, i, quote);
		if (!word)
			return;
		create_quoted_token(ms, k, word, quote, glued);
		(*i)++;
	}
	else
	{
		tokenize_normal_string(ms, k, i, glued);
	}
}



#include "minishell.h"

void	handle_eof(t_minishell *minishell)
{
	if (!minishell->input)
	{
		printf("exit\n");
		free_env(minishell->env);
		free_2d(minishell->envp);
		rl_clear_history();
		exit(0);
	}
}


#include "minishell.h"

void handle_heredoc_redir(t_minishell *minishell, int *k, int *i)
{
	minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
	if (!minishell->tok[*k])
		ft_exit(minishell, "Memory allocation failed", 1);
	minishell->tok[*k]->word = ft_strdup("<<");
	minishell->tok[*k]->type = INPUT_HEREDOC;
	minishell->tok[*k]->qtype = QUOTE_NONE;
	(*k)++;
	(*i) += 2;
}
#include "minishell.h"

void handle_input_file_redir(t_minishell *minishell, int *k, int *i)
{
	minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
	if (!minishell->tok[*k])
		ft_exit(minishell, "Memory allocation failed", 1);
	minishell->tok[*k]->word = ft_strdup("<");
	minishell->tok[*k]->type = INPUT_FILE;
	minishell->tok[*k]->qtype = QUOTE_NONE;
	(*k)++;
	(*i)++;
}
#include "minishell.h"

void handle_output_append_redir(t_minishell *minishell, int *k, int *i)
{
	minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
	if (!minishell->tok[*k])
		ft_exit(minishell, "Memory allocation failed", 1);
	minishell->tok[*k]->word = ft_strdup(">>");
	minishell->tok[*k]->type = OUTPUT_APPEND;
	minishell->tok[*k]->qtype = QUOTE_NONE;
	(*k)++;
	(*i) += 2;
}
#include "minishell.h"

void handle_output_file_redir(t_minishell *minishell, int *k, int *i)
{
	minishell->tok[*k] = ft_calloc(1, sizeof(t_token));
	if (!minishell->tok[*k])
		ft_exit(minishell, "Memory allocation failed", 1);
	minishell->tok[*k]->word = ft_strdup(">");
	minishell->tok[*k]->type = OUTPUT_FILE;
	minishell->tok[*k]->qtype = QUOTE_NONE;
	(*k)++;
	(*i)++;
}
#include "minishell.h"

// check if the token is not a redirection and argv inside one command
// not between pipes

void allocate_argv(t_minishell *minishell, int *argc, t_command **cmd, int *i)
{
	t_token *token = minishell->tok[*i];

	if (token->type == INPUT_PIPE || token->type == OUTPUT_PIPE)
	{
		(*cmd)->argv = malloc(sizeof(char *) * (*argc + 1));
		if (!(*cmd)->argv)
			ft_exit(minishell, "malloc failed", EXIT_FAILURE);
		*argc = 0;
		*cmd = (*cmd)->next;
	}
	else if (token->type != INPUT_FILE && token->type != INPUT_HEREDOC
		&& token->type != OUTPUT_FILE && token->type != OUTPUT_APPEND)
	{
		(*argc)++;
	}
}

#include "minishell.h"

// Last if is for last command after last pipe

void argv_for_commands(t_minishell *minishell)
{
	t_command *cmd = minishell->cmd;
	int i = 0;
	int argc = 0;

	while (minishell->tok[i])
	{
		allocate_argv(minishell, &argc, &cmd, &i);
		i++;
	}
	if (cmd)
	{
		cmd->argv = malloc(sizeof(char *) * (argc + 1));
		if (!cmd->argv)
			ft_exit(minishell, "malloc failed", EXIT_FAILURE);
	}
}

#include "minishell.h"

//? Steps:
//* 1. Initialize some of elements in the structure.
//* 2. Enter an infinite loop to display prompts.
//* 3. Clear the history if the loop has been broken.
int main(int ac, char **av, char **environ)
{
	(void)ac;
	(void)av;
	t_minishell minishell;
	init(&minishell);
	
	minishell.envp = ft_strdup_double (environ);
	minishell.env = init_env(&minishell, environ);
	main_loop(&minishell);
	rl_clear_history();
	return (0);
}// main_fork.c - Updated
#include "minishell.h"

void main_fork(t_minishell *shell)
{
    int status;
    pid_t pid;
    t_command *cmd = shell->cmd;
    
    if (!cmd || !cmd->argv || !cmd->argv[0])
    {
        shell->exit_code = 0;
        return;
    }
    
    // Handle builtin commands in parent (except in pipeline)
    if (is_builtin(cmd) && !cmd->next)
    {
        // Save original stdin/stdout
        int saved_stdin = dup(STDIN_FILENO);
        int saved_stdout = dup(STDOUT_FILENO);
        
        // Check redirections first
        if (!handle_redirection(shell))
        {
            shell->exit_code = 1;
            return;
        }
        
        // Apply redirections for builtin
        if (cmd->input_type == INPUT_FILE)
            input_redirection(cmd);
        if (cmd->output_type == OUTPUT_FILE || cmd->output_type == OUTPUT_APPEND)
            handle_output_redirection(cmd);
        
        // Execute builtin
        compare_commands(shell);
        
        // Restore stdin/stdout
        dup2(saved_stdin, STDIN_FILENO);
        dup2(saved_stdout, STDOUT_FILENO);
        close(saved_stdin);
        close(saved_stdout);
        
        return;
    }
    
    // Fork for external commands
    pid = fork();
    
    if (pid == -1)
    {
        ft_putstr_fd("minishell: ", STDERR_FILENO);
        perror("fork");
        shell->exit_code = EXIT_FAILURE;
        return;
    }
    
    if (pid == 0) // Child process
    {
        // Setup redirections
        main_redirection(shell);
        
        // Execute command
        compare_commands(shell);
        
        // Should never reach here
        exit(EXIT_FAILURE);
    }
    else // Parent process
    {
        waitpid(pid, &status, 0);
        if (WIFEXITED(status))
            shell->exit_code = WEXITSTATUS(status);
        else if (WIFSIGNALED(status))
        {
            shell->exit_code = 128 + WTERMSIG(status);
            if (WTERMSIG(status) == SIGINT)
                ft_putstr_fd("\n", STDOUT_FILENO);
        }
    }
}#include "minishell.h"
// main_loop.c - Updated section
void main_loop(t_minishell *minishell)
{
    print_banner();
    while (1)
    {
        setup_signals();
        init_shell(minishell);
        if (!minishell->input || !minishell->tok)
            continue;
        exit_builtin(minishell);
        init_commands(minishell);
        expand_tokens(minishell);
        merge_words(minishell);
        argv_for_commands(minishell);
        tokens_to_commands(minishell);
        if (!validate_pipeline(minishell))  // Add validation
        {
            check_to_free(minishell);
            continue;
        }
        if (!process_all_heredocs(minishell))
        {
            check_to_free(minishell);
            continue;
        }
        execute_pipeline(minishell);  // Replace main_fork with execute_pipeline
        check_to_free(minishell);
    }
}// main_redirection.c - Updated
#include "minishell.h"

void main_redirection(t_minishell *shell)
{
    t_command *cmd = shell->cmd;
    
    if (!cmd)
        return;
    
    // Handle heredoc input
    if (cmd->input_type == INPUT_HEREDOC)
    {
        if (!setup_heredoc_input(cmd))
            exit(EXIT_FAILURE);
    }
    // Handle file input
    else if (cmd->input_type == INPUT_FILE)
    {
        input_redirection(cmd);
    }
    
    // Handle output redirection
    if (cmd->output_type == OUTPUT_FILE || cmd->output_type == OUTPUT_APPEND)
    {
        handle_output_redirection(cmd);
    }
}
#include "minishell.h"

// — are called ASCII art, and specifically this style is known as a "FIGlet font".
//They are:
//Text rendered in blocky ASCII graphics, using characters like █, ║, ═, etc.
//Generated by FIGlet (short for Frank, Ian, and Glenn’s Letters), a tool that turns normal text into large, styled banners.
//The style I used above is a "ANSI Shadow" or "Big" font, which makes blocky uppercase letters look bold and powerful.

// Delay between characters (500 microseconds = 0.5ms)
void print_slowly(const char *line)
{
    int i;
    i = 0;
    while (line[i])
    {
        write(1, &line[i], 1);
        usleep(500);
        i++;
    }
}
void print_banner(void)
{
    const char *banner[] = {
        "\n",
        "\033[1;35m",
        "███╗   ███╗██╗███╗   ██╗██╗███████╗██╗  ██╗███████╗██╗     ██╗     \n",
        "████╗ ████║██║████╗  ██║██║██╔════╝██║  ██║██╔════╝██║     ██║     \n",
        "██╔████╔██║██║██╔██╗ ██║██║███████╗███████║█████╗  ██║     ██║     \n",
        "██║╚██╔╝██║██║██║╚██╗██║██║╚════██║██╔══██║██╔══╝  ██║     ██║     \n",
        "██║ ╚═╝ ██║██║██║ ╚████║██║███████║██║  ██║███████╗███████╗███████╗\n",
        "╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝\n",
        "\033[0m",
        "\n",
        NULL
    };
    int i = 0;
    while (banner[i])
    {
        print_slowly(banner[i]);
        usleep(80000); // 80ms between each line
        i++;
    }
}
