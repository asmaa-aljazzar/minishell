
#include "minishell.h"
int validate_syntax(t_minishell *ms)
{
    int i = 0;

    while (ms->tok[i])
    {
        if (ms->tok[i]->type == OUTPUT_PIPE)
        {
            // Starts with pipe
            if (i == 0 && ms->tok[i]->type != OUTPUT_PIPE)
            {
                ft_putendl_fd("minishell: syntax error near unexpected token `|'", 2);
                ms->exit_code = 2;
                return 0;
            }

            // Ends with pipe
            if (!ms->tok[i + 1])
            {
                ft_putendl_fd("minishell: syntax error near unexpected token `|'", 2);
                ms->exit_code = 2;
                return 0;
            }

            // Detect consecutive pipes (||, |||, etc.)
            if (ms->tok[i + 1] && ms->tok[i + 1]->type == OUTPUT_PIPE)
            {
                // Count how many consecutive pipes
                int j = i + 1;
                while (ms->tok[j] && ms->tok[j]->type == OUTPUT_PIPE)
                    j++;

                ft_putendl_fd("minishell: syntax error near unexpected token `||'", 2);
                ms->exit_code = 2;
                return 0;
            }
        }

        // Redirection check
        else if (ms->tok[i]->type == INPUT_FILE ||
                 ms->tok[i]->type == INPUT_HEREDOC ||
                 ms->tok[i]->type == OUTPUT_FILE ||
                 ms->tok[i]->type == OUTPUT_APPEND)
        {
            if (!ms->tok[i + 1] || ms->tok[i + 1]->type != INPUT_WORD)
            {
                ft_putendl_fd("minishell: syntax error near unexpected token `<>'", 2);
                ms->exit_code = 2;
                return 0;
            }
            i++; // skip filename token
        }

        i++;
    }

    return 1;
}


void init_shell(t_minishell *minishell)
{
    minishell->tok = NULL;
    minishell->tokens_count = 0;
    minishell->pipe_count = 0;
    minishell->input = readline(PROMPT);
    handle_eof(minishell);
    if (*minishell->input)
        add_history(minishell->input);
    if (!*minishell->input)
    {
        free(minishell->input);
        minishell->input = NULL;
        return;
    }
    get_tokens(minishell);
    if (!minishell->tok)
    {
        ft_putendl_fd("minishell: Error: Failed to tokenize input", STDERR_FILENO);
        free(minishell->input);
        minishell->input = NULL;
        return;
    }
    if (!validate_syntax(minishell))
    {
        check_to_free(minishell);
        minishell->exit_code = 2;
        return;
    }
    count_pipe(minishell);
}


#include "minishell.h"

char *read_quoted_content(t_minishell *ms, int *i, char quote)
{
	int start = ++(*i);
	while (ms->input[*i] && ms->input[*i] != quote)
		(*i)++;

	if (ms->input[*i] != quote)
	{
		ft_putendl_fd("minishell: syntax error: unmatched quote", STDERR_FILENO);
		return NULL;
	}
	int size = *i - start;
	char *word = malloc(size + 1);
	if (!word)
		ft_exit(ms, "minishell: Memory allocation failed", 1);
	ft_strlcpy(word, &ms->input[start], size + 1);
	return word;
}
#include "minishell.h"
// execute_pipeline.c
#include "minishell.h"

void execute_pipeline(t_minishell *shell)
{
    t_command *cmd = shell->cmd;
    int cmd_count = 0;
    
    // Count commands in pipeline
    while (cmd)
    {
        cmd_count++;
        cmd = cmd->next;
    }
    
    if (cmd_count == 0)
        return;
    
    if (cmd_count == 1)
    {
        // Single command case
        main_fork(shell);
        return;
    }
    
    // Multi-command pipeline
    execute_piped_commands(shell, cmd_count);
}

#include "minishell.h"
// execute_piped_commands.c
#include "minishell.h"

void execute_piped_commands(t_minishell *shell, int cmd_count)
{
    int (*pipes)[2] = malloc(sizeof(int[2]) * (cmd_count - 1));
    pid_t *pids = malloc(sizeof(pid_t) * cmd_count);
    int i;
    t_command *cmd;
    
    if (!pipes || !pids)
    {
        ft_putstr_fd("minishell: malloc failed\n", STDERR_FILENO);
        shell->exit_code = EXIT_FAILURE;
        free(pipes);
        free(pids);
        return;
    }
    
    // Create all pipes
    i = 0;
    while (i < cmd_count - 1)
    {
        if (pipe(pipes[i]) < 0)
        {
            ft_putstr_fd("minishell: pipe failed\n", STDERR_FILENO);
            shell->exit_code = EXIT_FAILURE;
            close_all_pipes(pipes, i);
            free(pipes);
            free(pids);
            return;
        }
        i++;
    }
    
    // Fork all children
    cmd = shell->cmd;
    i = 0;
    while (i < cmd_count && cmd)
    {
        pids[i] = fork();
        
        if (pids[i] < 0)
        {
            ft_putstr_fd("minishell: fork failed\n", STDERR_FILENO);
            shell->exit_code = EXIT_FAILURE;
            close_all_pipes(pipes, cmd_count - 1);
            free(pipes);
            free(pids);
            return;
        }
        
        if (pids[i] == 0)
        {
            
            // Set up pipes
            if (i > 0)  // Not first command
                dup2(pipes[i - 1][0], STDIN_FILENO);
            
            if (i < cmd_count - 1)  // Not last command
                dup2(pipes[i][1], STDOUT_FILENO);
            
            // Close all pipes
            close_all_pipes(pipes, cmd_count - 1);
            
            
            // Update shell->cmd to current command
            shell->cmd = cmd;
            // Handle redirections
            main_redirection(shell);
            
            // Execute command
            compare_commands(shell);
            
            // If builtin, exit with status
            if (is_builtin(cmd))
                exit(shell->exit_code);
            
            // Should never reach here for external commands
            exit(EXIT_FAILURE);
        }
        
        cmd = cmd->next;
        i++;
    }
    
    // Parent: close all pipes and wait
    close_all_pipes(pipes, cmd_count - 1);
    wait_for_children(shell, pids, cmd_count);
    
    free(pipes);
    free(pids);
}
// pipe_helpers.c
#include "minishell.h"

void close_all_pipes(int pipes[][2], int pipe_count)
{
    int i = 0;
    
    while (i < pipe_count)
    {
        close(pipes[i][0]);
        close(pipes[i][1]);
        i++;
    }
}

void wait_for_children(t_minishell *shell, pid_t *pids, int cmd_count)
{
    int i = 0;
    int status;
    
    while (i < cmd_count)
    {
        waitpid(pids[i], &status, 0);
        
        // Last command's status becomes shell's exit code
        if (i == cmd_count - 1)
        {
            if (WIFEXITED(status))
                shell->exit_code = WEXITSTATUS(status);
            else if (WIFSIGNALED(status))
                shell->exit_code = 128 + WTERMSIG(status);
        }
        i++;
    }
}
